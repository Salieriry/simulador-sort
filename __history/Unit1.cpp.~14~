#include <vcl.h>
#include <time.h>
#include <algorithm>
#pragma hdrstop

#include "Unit1.h"
#include "FormOpcoes.h"
#include "UFormGraficos.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;

// Variáveis globais
int vetor[1000], vetor2[1000], pos, aux, aux2, compara, troca, x, i, j, testa, d;
int delayCompare = 100; // Velocidade inicial de comparação em ms
int delaySwap = 100;    // Velocidade inicial de troca em ms
int maxVal = 100;      // Valor máximo inicial para números gerados
boolean preenchido = false, ordenado = false;
clock_t inicio, fim;
float tempo;

// Funções auxiliares
void atualizarGrafico(int vetor[], int posi, TChart *chart, TBarSeries *series, int idx1 = -1, int idx2 = -1) {

	series->Clear();
	for (int i = 0; i < pos; ++i) {
		// Verifica se o índice faz parte da troca atual
		if (i == idx1 || i == idx2) {
			series->AddXY(i, vetor[i], "", RGB(239, 242, 61)); // Cor da troca
		} else {
			series->AddXY(i, vetor[i], "", RGB(179, 89, 255)); // Cor padrão
		}
	}
	chart->Repaint();
	Application->ProcessMessages();
}


void delayComparacao() {
    Sleep(delayCompare);
}

void delayTroca() {
    Sleep(delaySwap);
}

// Algoritmos de ordenação
void bubbleSort(int vetor[], int pos, TChart *chart, TBarSeries *series) {
	compara = troca = 0;
	inicio = clock();

	for (int i = 0; i < pos; ++i) {
		for (int j = 0; j < pos - i - 1; ++j) {
			compara++;
			atualizarGrafico(vetor, pos, chart, series, j, j + 1); // Atualiza o gráfico durante a comparação
			delayComparacao();

			if (vetor[j] > vetor[j + 1]) {
				std::swap(vetor[j], vetor[j + 1]);
				troca++;
				atualizarGrafico(vetor, pos, chart, series, j, j + 1); // Destaque da troca
				delayTroca();
			}
		}
	}

	fim = clock();
	tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;
}


void insertionSort(int vetor[], int pos, TChart *chart, TBarSeries *series) {
	compara = troca = 0;
	inicio = clock();

	for (int i = 1; i < pos; ++i) {
		int key = vetor[i];
		int j = i;
	while (j > 0) {
		compara++;
		atualizarGrafico(vetor, pos, chart, series, j, j - 1); // Atualiza o gráfico durante a comparação
		delayComparacao();

		if (vetor[j - 1] > key) {
			vetor[j] = vetor[j - 1];
			troca++;
			atualizarGrafico(vetor, pos, chart, series, j, j - 1); // Destaque da troca
			delayTroca();
			j--;
		} else {
			break;
		}
	}
		vetor[j] = key;
		atualizarGrafico(vetor, pos, chart, series);
	}

	fim = clock();
	tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;
}

void shellSort(int vetor[], int pos, TChart *chart, TBarSeries *series) {
    compara = troca = 0;
    inicio = clock();

    for (int gap = pos / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < pos; i++) {
            int temp = vetor[i];
            int j;
            for (j = i; j >= gap; j -= gap) {
                compara++;
				delayComparacao();
                if (vetor[j - gap] > temp) {
                    vetor[j] = vetor[j - gap];
                    troca++;
                    atualizarGrafico(vetor, pos, chart, series, j, j - gap); // Destaque da troca
                    delayTroca();
                } else {
					break;
                }
            }
            vetor[j] = temp;
            atualizarGrafico(vetor, pos, chart, series);
		}
	}

	fim = clock();
	tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;
}


void selectionSort(int vetor[], int pos, TChart *chart, TBarSeries *series) {
    compara = troca = 0;
    inicio = clock();

    for (int i = 0; i < pos - 1; ++i) {
        int minIdx = i;
        for (int j = i + 1; j < pos; ++j) {
            compara++;
            delayComparacao();

            // Atualiza o gráfico periodicamente, mesmo durante comparações
            atualizarGrafico(vetor, pos, chart, series, i, j);

            if (vetor[j] < vetor[minIdx]) {
                minIdx = j;
            }
        }

        if (minIdx != i) {
            std::swap(vetor[i], vetor[minIdx]);
            troca++;
            atualizarGrafico(vetor, pos, chart, series, i, minIdx); // Destaque da troca
            delayTroca();
        }

        // Opcional: Chamar ProcessMessages para manter a interface responsiva
        Application->ProcessMessages();
    }

    fim = clock();
    tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;
}




void merge(int vetor[], int left, int mid, int right, TChart *chart, TBarSeries *series) {
	int n1 = mid - left + 1, n2 = right - mid;
	int* L = new int[n1];
	int* R = new int[n2];

	for (int i = 0; i < n1; ++i) L[i] = vetor[left + i];
	for (int i = 0; i < n2; ++i) R[i] = vetor[mid + 1 + i];

	int i = 0, j = 0, k = left;
	while (i < n1 && j < n2) {
		compara++;
		delayComparacao();
		if (L[i] <= R[j]) {
			vetor[k] = L[i++];
		} else {
			vetor[k] = R[j++];
		}
		troca++;
		atualizarGrafico(vetor, right + 1, chart, series, k, -1); // Destaque do índice sendo atualizado
		delayTroca();
		k++;
	}
	while (i < n1) {
		vetor[k++] = L[i++];
		troca++;
		atualizarGrafico(vetor, right + 1, chart, series, k - 1, -1);
		delayTroca();
	}
	while (j < n2) {
		vetor[k++] = R[j++];
		troca++;
		atualizarGrafico(vetor, right + 1, chart, series, k - 1, -1);
		delayTroca();
	}

	delete[] L;
	delete[] R;
}

void mergeSort(int vetor[], int left, int right, TChart *chart, TBarSeries *series) {
	if (left == 0 && right == pos - 1) {
		compara = troca = 0;
		inicio = clock();
	}

	if (left < right) {
		int mid = left + (right - left) / 2;
		mergeSort(vetor, left, mid, chart, series);
		mergeSort(vetor, mid + 1, right, chart, series);
		merge(vetor, left, mid, right, chart, series);
	}

	if (left == 0 && right == pos - 1) {
		fim = clock();
		tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;
	}
}


void quickSort(int vetor[], int low, int high, TChart *chart, TBarSeries *series) {
	if (low == 0 && high == pos - 1) {
		compara = troca = 0;
		inicio = clock();
	}

	if (low < high) {
		int pivot = vetor[high];
		int i = low;
	for (int j = low; j < high; ++j) {
		compara++;
		atualizarGrafico(vetor, high + 1, chart, series, j, -1); // Atualiza o gráfico durante a comparação
		delayComparacao();

		if (vetor[j] <= pivot) {
			std::swap(vetor[i], vetor[j]);
			troca++;
			atualizarGrafico(vetor, high + 1, chart, series, i, j); // Destaque da troca
			delayTroca();
			i++;
		}
	}
		std::swap(vetor[i], vetor[high]);
		troca++;
		atualizarGrafico(vetor, high + 1, chart, series, i, high);
		delayTroca();

		quickSort(vetor, low, i - 1, chart, series);
		quickSort(vetor, i + 1, high, chart, series);
	}

	if (low == 0 && high == pos - 1) {
		fim = clock();
		tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;
	}
}


void heapify(int vetor[], int pos, int i, TChart *chart, TBarSeries *series) {
	int largest = i, left = 2 * i + 1, right = 2 * i + 2;

	// Comparação com o filho esquerdo
	if (left < pos) {
		compara++;
		atualizarGrafico(vetor, pos, chart, series, i, left); // Destaca a comparação
		delayComparacao();
		if (vetor[left] > vetor[largest]) largest = left;
	}

	// Comparação com o filho direito
	if (right < pos) {
		compara++;
		atualizarGrafico(vetor, pos, chart, series, i, right); // Destaca a comparação
		delayComparacao();
		if (vetor[right] > vetor[largest]) largest = right;
	}

	// Realiza a troca, se necessário
	if (largest != i) {
		std::swap(vetor[i], vetor[largest]);
		troca++;
		atualizarGrafico(vetor, pos, chart, series, i, largest); // Destaque da troca
		delayTroca();

		// Recursão para ajustar o restante da heap
		heapify(vetor, pos, largest, chart, series);
	} else {
		// Atualiza o gráfico mesmo quando nenhuma troca ocorre
		atualizarGrafico(vetor, pos, chart, series, i, -1);
	}
}

void heapSort(int vetor[], int pos, TChart *chart, TBarSeries *series) {
	compara = troca = 0;
	inicio = clock();

	// Construção da heap
	for (int i = pos / 2 - 1; i >= 0; --i) {
		heapify(vetor, pos, i, chart, series);
		atualizarGrafico(vetor, pos, chart, series, i, -1); // Atualiza após cada ajuste da heap
		delayTroca();
	}

	// Extração dos elementos da heap
	for (int i = pos - 1; i > 0; --i) {
		// Troca o maior elemento para o final do vetor
		std::swap(vetor[0], vetor[i]);
		troca++;
		atualizarGrafico(vetor, pos, chart, series, 0, i); // Destaque da troca
		delayTroca();

		// Ajusta a heap reduzida
		heapify(vetor, i, 0, chart, series);
	}

	fim = clock();
	tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;
}



// Algoritmos de Busca
int linearSearch(int vetor[], int pos, int valor, int &comparar) {
	comparar = 0; // Reinicia contagem de comparações
	for (i = 0; i < pos; ++i) {
		comparar++;
		delayComparacao();
		if (vetor[i] == valor) {
			return i; // Retorna a posição encontrada
		}
	}
	return -1; // Valor não encontrado
}

int binarySearch(int vetor[], int low, int high, int valor, int &comparar) {
	comparar = 0; // Reinicia contagem de comparações
	while (low <= high) {
		int mid = low + (high - low) / 2;
		delayComparacao();
		comparar++;
		if (vetor[mid] == valor) {
			return mid; // Valor encontrado
		} else if (vetor[mid] < valor) {
			low = mid + 1; // Busca no lado direito
		} else {
			high = mid - 1; // Busca no lado esquerdo
		}
	}
	return -1; // Valor não encontrado
}

String formatarTempo(float tempoSegundos) {
	int horas = tempoSegundos / 3600;
	int minutos = (tempoSegundos - horas * 3600) / 60;
	int segundos = (int)tempoSegundos % 60;
	int milissegundos = (tempoSegundos - (int)tempoSegundos) * 1000;

	return FormatFloat("00", horas) + ":" +
		   FormatFloat("00", minutos) + ":" +
		   FormatFloat("00", segundos) + ":" +
		   FormatFloat("000", milissegundos);
}

//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner) {

	}

// Botão para ordenar os valores
void __fastcall TForm1::evOrdenarValores(TObject *Sender) {
    int selectedIndex = cbSort->ItemIndex;

    if (selectedIndex < 0 || selectedIndex > 6) { // Atualizado: agora há 7 opções
        ShowMessage("Selecione um algoritmo válido!");
        return;
    }

    if (preenchido) {
        switch (selectedIndex) {
            case 0:
                bubbleSort(vetor, pos, Chart1, Series1);
                reResultados->Lines->Add("Método BubbleSort - Comparações: " +
                    IntToStr(compara) + " | Trocas: " + IntToStr(troca) +
					" | Tempo de execução: " + formatarTempo(tempo));
                break;
            case 1:
                insertionSort(vetor, pos, Chart1, Series1);
                reResultados->Lines->Add("Método InsertionSort - Comparações: " +
                    IntToStr(compara) + " | Trocas: " + IntToStr(troca) +
					" | Tempo de execução: " + formatarTempo(tempo));
                break;
            case 2: // Novo caso para ShellSort
                shellSort(vetor, pos, Chart1, Series1);
                reResultados->Lines->Add("Método ShellSort - Comparações: " +
                    IntToStr(compara) + " | Trocas: " + IntToStr(troca) +
					" | Tempo de execução: " + formatarTempo(tempo));
                break;
            case 3:
                selectionSort(vetor, pos, Chart1, Series1);
                reResultados->Lines->Add("Método SelectionSort - Comparações: " +
                    IntToStr(compara) + " | Trocas: " + IntToStr(troca) +
					" | Tempo de execução: " + formatarTempo(tempo));
                break;
            case 4:
                mergeSort(vetor, 0, pos - 1, Chart1, Series1);
                reResultados->Lines->Add("Método MergeSort - Comparações: " +
                    IntToStr(compara) + " | Trocas: " + IntToStr(troca) +
					" | Tempo de execução: " + formatarTempo(tempo));
				break;
            case 5:
                quickSort(vetor, 0, pos - 1, Chart1, Series1);
                reResultados->Lines->Add("Método QuickSort - Comparações: " +
                    IntToStr(compara) + " | Trocas: " + IntToStr(troca) +
					" | Tempo de execução: " + formatarTempo(tempo));
                break;
            case 6:
                heapSort(vetor, pos, Chart1, Series1);
                reResultados->Lines->Add("Método HeapSort - Comparações: " +
                    IntToStr(compara) + " | Trocas: " + IntToStr(troca) +
					" | Tempo de execução: " + formatarTempo(tempo));
                break;
        }

        tbComparacao->Text = IntToStr(compara);
        tbTrocas->Text = IntToStr(troca);
		ordenado = true;

    } else {
        ShowMessage("Gráfico não preenchido.");
    }
}


// Botão para gerar novos valores
void __fastcall TForm1::evGerarValores(TObject *Sender) {
	// Lê o número de valores desejado e verifica os limites
	int numValores = StrToIntDef(tbValor->Text, -1);
	if (numValores < 1 || numValores > maxVal) {
		ShowMessage("Por favor, insira um valor entre 10 e " + IntToStr(maxVal) + ".");
		return;
	}

    // Verifica se excede o máximo permitido
    if (numValores > maxVal) {
        ShowMessage("O número de valores não pode exceder " + IntToStr(maxVal) + ".");
        return;
    }

    pos = numValores; // Atualiza o número de elementos gerados
    Series1->Clear(); // Limpa os valores existentes no gráfico

    Randomize(); // Inicializa o gerador de números aleatórios

    // Preenche o vetor com valores aleatórios e associa cores
	for (i = 0; i < pos; ++i) {
        vetor[i] = Random(500); // Gera valores aleatórios de 0 a 499
		vetor2[i] = vetor[i];
		Series1->AddXY(i, vetor2[i], "", RGB(179, 89, 255)); // Adiciona ao gráfico
    }

    preenchido = true; // Marca como preenchido
    Chart1->Repaint(); // Atualiza o gráfico visualmente

    // Exibe uma mensagem com o número de valores gerados
    ShowMessage("Gráfico atualizado com " + IntToStr(pos) + " valores (máximo permitido: " + IntToStr(maxVal) + ").");
    ordenado = false; // Marca como não ordenado
}


// Botão para restaurar os valores originais
void __fastcall TForm1::evTrocarOriginal(TObject *Sender) {
	for (int i = 0; i < pos; ++i) {
		vetor[i] = vetor2[i];
	}
	atualizarGrafico(vetor, pos, Chart1, Series1);
	ordenado = false;
	ShowMessage("Valores restaurados para o original.");
}

// evento para impedir dígitos não permitidos
void __fastcall TForm1::evApenasNumeros(TObject *Sender, System::WideChar &Key)
{
	if (!isdigit(Key) && Key != VK_BACK) {

		Key = 0;

	}
}
void __fastcall TForm1::evLimpar(TObject *Sender)
{
	Series1->Clear();
	reResultados->Lines->Clear();
	tbComparacao->Clear();
	tbTrocas->Clear();
	preenchido = false;
}
//---------------------------------------------------------------------------

void __fastcall TForm1::evSair(TObject *Sender)
{
    this->Close();
}
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------


void __fastcall TForm1::evBuscarValor(TObject *Sender)
{
	if (!preenchido) {
		ShowMessage("Gráfico não preenchido.");
		return;
	}

	int valor = StrToIntDef(tbBusca->Text, -1); // Valor a ser buscado
	if (valor < 0) {
		ShowMessage("Por favor, insira um valor válido para buscar.");
		return;
	}

	int resultado = -1;
	int comparar = 0;
	clock_t inicio, fim;
    float tempo;

	switch (cbBusca->ItemIndex) { // Verifica o índice da busca selecionada
        case 0: // Busca Linear
            inicio = clock();
			resultado = linearSearch(vetor, pos, valor, comparar);
            fim = clock();
            tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;

			if (resultado != -1) {
			   reResultados->Lines->Add("Método LinearSearch - Comparações: " +
				IntToStr(comparar) + " | Tempo de execução: " +
				FloatToStr(tempo) + " segundos | Resultado: " +
				 "Valor encontrado na posição " + IntToStr(resultado));
			}
			else {
			  reResultados->Lines->Add("Método LinearSearch - Comparações: " +
				IntToStr(comparar) + " | Tempo de execução: " +
				FloatToStr(tempo) + " segundos | Resultado: " +
				 "Valor não encontrado. ");
			}

			break;

        case 1: // Busca Binária
            if (!ordenado) {
                ShowMessage("Vetor não está ordenado. Ordene o vetor antes de realizar a busca binária.");
                return;
			}
            inicio = clock();
			resultado = binarySearch(vetor, 0, pos - 1, valor, comparar);
            fim = clock();
            tempo = ((float)(fim - inicio)) / CLOCKS_PER_SEC;


			if (resultado != -1) {
			   reResultados->Lines->Add("Método BinarySearch - Comparações: " +
				IntToStr(comparar) + " | Tempo de execução: " +
				FloatToStr(tempo) + " segundos | Resultado: " +
				 "Valor encontrado na posição " + IntToStr(resultado));;
			}
			else {
			  reResultados->Lines->Add("Método LinearSearch - Comparações: " +
				IntToStr(comparar) + " | Tempo de execução: " +
				FloatToStr(tempo) + " segundos | Resultado: " +
				 "Valor não encontrado. ");
			}

            break;

        default:
            ShowMessage("Selecione um algoritmo de busca válido!");
            return;
	}
}

//---------------------------------------------------------------------------

void __fastcall TForm1::evMostrarValores(TObject *Sender)
{
	static bool valoresVisiveis = false; // Estado inicial: valores escondidos

    valoresVisiveis = !valoresVisiveis; // Alterna o estado

    Series1->Marks->Visible = valoresVisiveis; // Exibe ou oculta os valores

    if (valoresVisiveis) {
        ShowMessage("Valores agora estão visíveis.");
    } else {
        ShowMessage("Valores agora estão ocultos.");
	}
}
//---------------------------------------------------------------------------

void __fastcall TForm1::evAbrirOpcoes(TObject *Sender)
{

	TFormOptions *formOptions = new TFormOptions(this);

	if (formOptions->Visible) {
		formOptions->Hide();
	}


	formOptions->ShowModal();

	delete formOptions;


}
//---------------------------------------------------------------------------

void __fastcall TForm1::evAbrirEstatisticas(TObject *Sender)
{
	TFormGraficos *formGraficos = new TFormGraficos(this);

	if (formGraficos->Visible) {
		formGraficos->Hide();
	}


	formGraficos->ShowModal();

	delete formGraficos;
}
//---------------------------------------------------------------------------
